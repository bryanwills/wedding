"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AST: () => ast_exports,
  ParseError: () => ParseError,
  VisitorKeys: () => VisitorKeys,
  parseForESLint: () => parseForESLint2,
  parseTemplate: () => parseTemplate2,
  traverseNodes: () => traverseNodes
});
module.exports = __toCommonJS(src_exports);

// src/visitor-keys.ts
var import_eslint_visitor_keys = require("eslint-visitor-keys");
var astroKeys = {
  Program: ["body"],
  AstroFragment: ["children"],
  AstroHTMLComment: [],
  AstroDoctype: [],
  AstroShorthandAttribute: ["name", "value"],
  AstroTemplateLiteralAttribute: ["name", "value"],
  AstroRawText: []
};
var KEYS = (0, import_eslint_visitor_keys.unionWith)(
  astroKeys
);

// src/parser/index.ts
var import_types2 = require("@typescript-eslint/types");

// src/debug.ts
var import_debug = __toESM(require("debug"));
var debug = (0, import_debug.default)("astro-eslint-parser");

// src/parser/ts-patch.ts
var import_module = require("module");
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
function tsPatch(scriptParserOptions) {
  let targetExt = ".astro";
  if (scriptParserOptions.filePath) {
    const ext = import_path.default.extname(scriptParserOptions.filePath);
    if (ext) {
      targetExt = ext;
    }
  }
  try {
    const cwd = process.cwd();
    const relativeTo = import_path.default.join(cwd, "__placeholder__.js");
    const ts = (0, import_module.createRequire)(relativeTo)("typescript");
    const { ensureScriptKind, getScriptKindFromFileName } = ts;
    if (typeof ensureScriptKind === "function" && typeof getScriptKindFromFileName === "function") {
      ts.ensureScriptKind = function(fileName, ...args) {
        if (fileName.endsWith(targetExt)) {
          return ts.ScriptKind.TSX;
        }
        return ensureScriptKind.call(this, fileName, ...args);
      };
      ts.getScriptKindFromFileName = function(fileName, ...args) {
        if (fileName.endsWith(targetExt)) {
          return ts.ScriptKind.TSX;
        }
        return getScriptKindFromFileName.call(this, fileName, ...args);
      };
      return {
        terminate() {
          ts.ensureScriptKind = ensureScriptKind;
          ts.getScriptKindFromFileName = getScriptKindFromFileName;
        }
      };
    }
  } catch {
  }
  const tsxFilePath = `${scriptParserOptions.filePath}.tsx`;
  scriptParserOptions.filePath = tsxFilePath;
  if (!import_fs.default.existsSync(tsxFilePath)) {
    import_fs.default.writeFileSync(tsxFilePath, "/* temp for astro-eslint-parser */");
    return {
      terminate() {
        import_fs.default.unlinkSync(tsxFilePath);
      }
    };
  }
  return null;
}

// src/context/resolve-parser/parser-object.ts
function isParserObject(value) {
  return isEnhancedParserObject(value) || isBasicParserObject(value);
}
function isEnhancedParserObject(value) {
  return Boolean(value && typeof value.parseForESLint === "function");
}
function isBasicParserObject(value) {
  return Boolean(value && typeof value.parse === "function");
}
function maybeTSESLintParserObject(value) {
  return isEnhancedParserObject(value) && isBasicParserObject(value) && typeof value.createProgram === "function" && typeof value.clearCaches === "function" && typeof value.version === "string";
}

// src/parser/script.ts
function parseScript(code, _ctx, parserOptions) {
  const parser = parserOptions.getParser();
  let patchResult;
  try {
    const scriptParserOptions = {
      ...parserOptions.parserOptions
    };
    scriptParserOptions.ecmaFeatures = {
      ...scriptParserOptions.ecmaFeatures || {},
      jsx: true
    };
    if (parserOptions.isTypeScript() && scriptParserOptions.filePath && scriptParserOptions.project) {
      patchResult = tsPatch(scriptParserOptions);
    }
    const result = isEnhancedParserObject(parser) ? parser.parseForESLint(code, scriptParserOptions) : parser.parse(code, scriptParserOptions);
    if ("ast" in result && result.ast != null) {
      return result;
    }
    return { ast: result };
  } catch (e) {
    debug(
      "[script] parsing error:",
      e.message,
      `@ ${JSON.stringify(code)}

${code}`
    );
    throw e;
  } finally {
    patchResult == null ? void 0 : patchResult.terminate();
  }
}

// src/parser/sort.ts
function sort(tokens) {
  return tokens.sort((a, b) => {
    if (a.range[0] !== b.range[0]) {
      return a.range[0] - b.range[0];
    }
    return a.range[1] - b.range[1];
  });
}

// src/parser/process-template.ts
var import_types = require("@typescript-eslint/types");

// src/errors.ts
var ParseError = class extends SyntaxError {
  constructor(message, offset, ctx) {
    super(message);
    this.index = offset;
    const loc = ctx.getLocFromIndex(offset);
    this.lineNumber = loc.line;
    this.column = loc.column;
    this.originalAST = ctx.originalAST;
  }
};

// src/astro/index.ts
function isTag(node) {
  return node.type === "element" || node.type === "custom-element" || node.type === "component" || node.type === "fragment";
}
function isParent(node) {
  return Array.isArray(node.children);
}
function walkElements(parent, code, enter, leave, parents = []) {
  const children = getSortedChildren(parent, code);
  const currParents = [parent, ...parents];
  for (const node of children) {
    enter(node, currParents);
    if (isParent(node)) {
      walkElements(node, code, enter, leave, currParents);
    }
    leave(node, currParents);
  }
}
function walk(parent, code, enter, leave) {
  walkElements(
    parent,
    code,
    (node, parents) => {
      enter(node, parents);
      if (isTag(node)) {
        const attrParents = [node, ...parents];
        for (const attr of node.attributes) {
          enter(attr, attrParents);
          leave(attr, attrParents);
        }
      }
    },
    leave
  );
}
function calcStartTagEndOffset(node, ctx) {
  const lastAttr = node.attributes[node.attributes.length - 1];
  let beforeCloseIndex;
  if (lastAttr) {
    beforeCloseIndex = calcAttributeEndOffset(lastAttr, ctx);
  } else {
    const info2 = getTokenInfo(
      ctx,
      [`<${node.name}`],
      node.position.start.offset
    );
    beforeCloseIndex = info2.index + info2.match.length;
  }
  const info = getTokenInfo(ctx, [[">", "/>"]], beforeCloseIndex);
  return info.index + info.match.length;
}
function calcAttributeEndOffset(node, ctx) {
  let info;
  if (node.kind === "empty") {
    info = getTokenInfo(ctx, [node.name], node.position.start.offset);
  } else if (node.kind === "quoted") {
    info = getTokenInfo(
      ctx,
      [[`"${node.value}"`, `'${node.value}'`, node.value]],
      calcAttributeValueStartOffset(node, ctx)
    );
  } else if (node.kind === "expression") {
    info = getTokenInfo(
      ctx,
      ["{", node.value, "}"],
      calcAttributeValueStartOffset(node, ctx)
    );
  } else if (node.kind === "shorthand") {
    info = getTokenInfo(
      ctx,
      ["{", node.name, "}"],
      node.position.start.offset
    );
  } else if (node.kind === "spread") {
    info = getTokenInfo(
      ctx,
      ["{", "...", node.name, "}"],
      node.position.start.offset
    );
  } else if (node.kind === "template-literal") {
    info = getTokenInfo(
      ctx,
      [`\`${node.value}\``],
      calcAttributeValueStartOffset(node, ctx)
    );
  } else {
    throw new ParseError(
      `Unknown attr kind: ${node.kind}`,
      node.position.start.offset,
      ctx
    );
  }
  return info.index + info.match.length;
}
function calcAttributeValueStartOffset(node, ctx) {
  let info;
  if (node.kind === "quoted") {
    info = getTokenInfo(
      ctx,
      [node.name, "=", [`"`, `'`, node.value]],
      node.position.start.offset
    );
  } else if (node.kind === "expression") {
    info = getTokenInfo(
      ctx,
      [node.name, "=", "{"],
      node.position.start.offset
    );
  } else if (node.kind === "template-literal") {
    info = getTokenInfo(
      ctx,
      [node.name, "=", "`"],
      node.position.start.offset
    );
  } else {
    throw new ParseError(
      `Unknown attr kind: ${node.kind}`,
      node.position.start.offset,
      ctx
    );
  }
  return info.index;
}
function getEndOffset(node, ctx) {
  var _a;
  if (((_a = node.position.end) == null ? void 0 : _a.offset) != null) {
    return node.position.end.offset;
  }
  if (isTag(node))
    return calcTagEndOffset(node, ctx);
  if (node.type === "expression")
    return calcExpressionEndOffset(node, ctx);
  if (node.type === "comment")
    return calcCommentEndOffset(node, ctx);
  if (node.type === "frontmatter") {
    const start = node.position.start.offset;
    return ctx.code.indexOf("---", start + 3) + 3;
  }
  if (node.type === "doctype") {
    const start = node.position.start.offset;
    return ctx.code.indexOf(">", start) + 1;
  }
  if (node.type === "text") {
    const start = node.position.start.offset;
    return start + node.value.length;
  }
  if (node.type === "root") {
    return ctx.code.length;
  }
  throw new Error(`unknown type: ${node.type}`);
}
function calcContentEndOffset(parent, ctx) {
  const code = ctx.code;
  if (isTag(parent)) {
    const end = getEndOffset(parent, ctx);
    if (code[end - 1] !== ">") {
      return end;
    }
    const index = code.lastIndexOf("</", end - 1);
    if (index >= 0 && code.slice(index + 2, end - 1).trim() === parent.name) {
      return index;
    }
    return end;
  } else if (parent.type === "expression") {
    const end = getEndOffset(parent, ctx);
    return code.lastIndexOf("}", end);
  } else if (parent.type === "root") {
    return code.length;
  }
  throw new Error(`unknown type: ${parent.type}`);
}
function getSelfClosingTag(node, ctx) {
  if (node.children.length > 0) {
    return null;
  }
  const code = ctx.code;
  const startTagEndOffset = calcStartTagEndOffset(node, ctx);
  if (code.startsWith("/>", startTagEndOffset - 2)) {
    return {
      offset: startTagEndOffset,
      end: "/>"
    };
  }
  if (code.startsWith(`</${node.name}`, startTagEndOffset)) {
    return null;
  }
  return {
    offset: startTagEndOffset,
    end: ">"
  };
}
function getEndTag(node, ctx) {
  let beforeIndex;
  if (node.children.length) {
    const lastChild = node.children[node.children.length - 1];
    beforeIndex = getEndOffset(lastChild, ctx);
  } else {
    beforeIndex = calcStartTagEndOffset(node, ctx);
  }
  beforeIndex = skipSpaces(ctx.code, beforeIndex);
  if (ctx.code.startsWith(`</${node.name}`, beforeIndex)) {
    const offset = beforeIndex;
    beforeIndex = beforeIndex + 2 + node.name.length;
    const info = getTokenInfo(ctx, [">"], beforeIndex);
    const end = info.index + info.match.length;
    return {
      offset,
      tag: ctx.code.slice(offset, end)
    };
  }
  return null;
}
function calcCommentEndOffset(node, ctx) {
  const info = getTokenInfo(
    ctx,
    ["<!--", node.value, "-->"],
    node.position.start.offset
  );
  return info.index + info.match.length;
}
function calcTagEndOffset(node, ctx) {
  let beforeIndex;
  if (node.children.length) {
    const lastChild = node.children[node.children.length - 1];
    beforeIndex = getEndOffset(lastChild, ctx);
  } else {
    beforeIndex = calcStartTagEndOffset(node, ctx);
  }
  beforeIndex = skipSpaces(ctx.code, beforeIndex);
  if (ctx.code.startsWith(`</${node.name}`, beforeIndex)) {
    beforeIndex = beforeIndex + 2 + node.name.length;
    const info = getTokenInfo(ctx, [">"], beforeIndex);
    return info.index + info.match.length;
  }
  return beforeIndex;
}
function calcExpressionEndOffset(node, ctx) {
  if (node.children.length) {
    const lastChild = node.children[node.children.length - 1];
    const beforeIndex = getEndOffset(lastChild, ctx);
    const info2 = getTokenInfo(ctx, ["}"], beforeIndex);
    return info2.index + info2.match.length;
  }
  const info = getTokenInfo(ctx, ["{", "}"], node.position.start.offset);
  return info.index + info.match.length;
}
function getTokenInfo(ctx, tokens, position) {
  let lastMatch;
  for (const t of tokens) {
    const index = lastMatch ? lastMatch.index + lastMatch.match.length : position;
    const m = typeof t === "string" ? matchOfStr(t, index) : matchOfForMulti(t, index);
    if (m == null) {
      throw new ParseError(
        `Unknown token at ${index}, expected: ${JSON.stringify(
          t
        )}, actual: ${JSON.stringify(ctx.code.slice(index, index + 10))}`,
        index,
        ctx
      );
    }
    lastMatch = m;
  }
  return lastMatch;
  function matchOfStr(search, position2) {
    const index = search.trim() === search ? skipSpaces(ctx.code, position2) : position2;
    if (ctx.code.startsWith(search, index)) {
      return {
        match: search,
        index
      };
    }
    return null;
  }
  function matchOfForMulti(search, position2) {
    for (const s of search) {
      const m = matchOfStr(s, position2);
      if (m) {
        return m;
      }
    }
    return null;
  }
}
function skipSpaces(string, position) {
  const re = /\s*/g;
  re.lastIndex = position;
  const match = re.exec(string);
  if (match) {
    return match.index + match[0].length;
  }
  return position;
}
function getSortedChildren(parent, code) {
  var _a;
  if (parent.type === "root" && ((_a = parent.children[0]) == null ? void 0 : _a.type) === "frontmatter") {
    const children = [...parent.children];
    if (children.every((n) => n.position)) {
      return children.sort(
        (a, b) => a.position.start.offset - b.position.start.offset
      );
    }
    let start = skipSpaces(code, 0);
    if (code.startsWith("<!", start)) {
      const frontmatter = children.shift();
      const before = [];
      let first;
      while (first = children.shift()) {
        start = skipSpaces(code, start);
        if (first.type === "comment" && code.startsWith("<!--", start)) {
          start = code.indexOf("-->", start + 4) + 3;
          before.push(first);
        } else if (first.type === "doctype" && code.startsWith("<!", start)) {
          start = code.indexOf(">", start + 2) + 1;
          before.push(first);
        } else {
          children.unshift(first);
          break;
        }
      }
      return [...before, frontmatter, ...children];
    }
  }
  return parent.children;
}

// src/traverse.ts
function fallbackKeysFilter(key) {
  let value = null;
  return key !== "comments" && key !== "leadingComments" && key !== "loc" && key !== "parent" && key !== "range" && key !== "tokens" && key !== "trailingComments" && (value = this[key]) !== null && typeof value === "object" && (typeof value.type === "string" || Array.isArray(value));
}
function getFallbackKeys(node) {
  return Object.keys(node).filter(fallbackKeysFilter, node);
}
function getKeys(node, visitorKeys) {
  const keys = (visitorKeys || KEYS)[node.type] || getFallbackKeys(node);
  return keys.filter((key) => !getNodes(node, key).next().done);
}
function* getNodes(node, key) {
  const child = node[key];
  if (Array.isArray(child)) {
    for (const c of child) {
      if (isNode(c)) {
        yield c;
      }
    }
  } else if (isNode(child)) {
    yield child;
  }
}
function isNode(x) {
  return x !== null && typeof x === "object" && typeof x.type === "string";
}
function traverse(node, parent, visitor) {
  visitor.enterNode(node, parent);
  const keys = getKeys(node, visitor.visitorKeys);
  for (const key of keys) {
    for (const child of getNodes(node, key)) {
      traverse(child, node, visitor);
    }
  }
  visitor.leaveNode(node, parent);
}
function traverseNodes(node, visitor) {
  traverse(node, null, visitor);
}

// src/context/script.ts
var RestoreNodeProcessContext = class {
  constructor(result, parentMap) {
    this.removeTokens = /* @__PURE__ */ new Set();
    this.result = result;
    this.parentMap = parentMap;
  }
  addRemoveToken(test) {
    this.removeTokens.add(test);
  }
  getParent(node) {
    return this.parentMap.get(node) || null;
  }
};
var ScriptContext = class {
  constructor(ctx) {
    this.script = "";
    this.consumedIndex = 0;
    this.offsets = [];
    this.fragments = [];
    this.tokens = [];
    this.restoreNodeProcesses = [];
    this.ctx = ctx;
  }
  get originalCode() {
    return this.ctx.code;
  }
  skipOriginalOffset(offset) {
    this.consumedIndex += offset;
  }
  appendOriginal(index) {
    if (this.consumedIndex >= index) {
      return;
    }
    this.offsets.push({
      original: this.consumedIndex,
      script: this.script.length
    });
    this.script += this.ctx.code.slice(this.consumedIndex, index);
    this.consumedIndex = index;
  }
  appendScript(fragment) {
    const start = this.script.length;
    this.script += fragment;
    this.fragments.push({ start, end: this.script.length });
  }
  addToken(type, range) {
    if (range[0] >= range[1]) {
      return;
    }
    this.tokens.push(this.ctx.buildToken(type, range));
  }
  addRestoreNodeProcess(process2) {
    this.restoreNodeProcesses.push(process2);
  }
  restore(result) {
    var _a, _b;
    const traversed = /* @__PURE__ */ new Map();
    traverseNodes(result.ast, {
      visitorKeys: result.visitorKeys,
      enterNode: (node, p) => {
        if (!traversed.has(node)) {
          traversed.set(node, p);
          this.remapLocation(node);
        }
      },
      leaveNode: (_node) => {
      }
    });
    const tokens = [...this.tokens];
    for (const token of result.ast.tokens || []) {
      if (this.fragments.some(
        (f) => f.start <= token.range[0] && token.range[1] <= f.end
      )) {
        continue;
      }
      this.remapLocation(token);
      tokens.push(token);
    }
    result.ast.tokens = tokens;
    for (const token of result.ast.comments || []) {
      this.remapLocation(token);
    }
    const context = new RestoreNodeProcessContext(result, traversed);
    let restoreNodeProcesses = this.restoreNodeProcesses;
    for (const [node, parent] of traversed) {
      if (!parent)
        continue;
      restoreNodeProcesses = restoreNodeProcesses.filter(
        (proc) => !proc(node, context)
      );
    }
    if (context.removeTokens.size) {
      const tokens2 = result.ast.tokens || [];
      for (let index = tokens2.length - 1; index >= 0; index--) {
        const token = tokens2[index];
        for (const rt of context.removeTokens) {
          if (rt(token)) {
            tokens2.splice(index, 1);
            context.removeTokens.delete(rt);
            if (!context.removeTokens.size) {
              break;
            }
          }
        }
      }
    }
    const firstOffset = Math.min(
      ...[result.ast.body[0], (_a = result.ast.tokens) == null ? void 0 : _a[0], (_b = result.ast.comments) == null ? void 0 : _b[0]].filter(Boolean).map((t) => t.range[0])
    );
    if (firstOffset < result.ast.range[0]) {
      result.ast.range[0] = firstOffset;
      result.ast.loc.start = this.ctx.getLocFromIndex(firstOffset);
    }
  }
  remapLocation(node) {
    let [start, end] = node.range;
    const startFragment = this.fragments.find(
      (f) => f.start <= start && start < f.end
    );
    if (startFragment) {
      start = startFragment.end;
    }
    const endFragment = this.fragments.find(
      (f) => f.start < end && end <= f.end
    );
    if (endFragment) {
      end = endFragment.start;
    }
    if (end < start) {
      const w = start;
      start = end;
      end = w;
    }
    const locs = this.ctx.getLocations(...this.getRemapRange(start, end));
    node.loc = locs.loc;
    node.range = locs.range;
    if (node.start != null) {
      delete node.start;
    }
    if (node.end != null) {
      delete node.end;
    }
  }
  getRemapRange(start, end) {
    if (!this.offsets.length) {
      return [start, end];
    }
    let lastStart = this.offsets[0];
    let lastEnd = this.offsets[0];
    for (const offset of this.offsets) {
      if (offset.script <= start) {
        lastStart = offset;
      }
      if (offset.script < end) {
        lastEnd = offset;
      } else {
        if (offset.script === end) {
          const remapStart2 = lastStart.original + (start - lastStart.script);
          if (this.tokens.some(
            (t) => t.range[0] <= remapStart2 && offset.original <= t.range[1]
          )) {
            lastEnd = offset;
          }
        }
        break;
      }
    }
    const remapStart = lastStart.original + (start - lastStart.script);
    const remapEnd = lastEnd.original + (end - lastEnd.script);
    return [remapStart, remapEnd];
  }
};

// src/parser/process-template.ts
function processTemplate(ctx, resultTemplate) {
  let uniqueIdSeq = 0;
  const usedUniqueIds = /* @__PURE__ */ new Set();
  const script = new ScriptContext(ctx);
  let fragmentOpened = false;
  function openRootFragment(startOffset) {
    script.appendScript("<>");
    fragmentOpened = true;
    script.addRestoreNodeProcess((scriptNode, { result }) => {
      if (scriptNode.type === import_types.AST_NODE_TYPES.ExpressionStatement && scriptNode.expression.type === import_types.AST_NODE_TYPES.JSXFragment && scriptNode.range[0] === startOffset && result.ast.body.includes(scriptNode)) {
        const index = result.ast.body.indexOf(scriptNode);
        const rootFragment = result.ast.body[index] = scriptNode.expression;
        delete rootFragment.closingFragment;
        delete rootFragment.openingFragment;
        rootFragment.type = "AstroFragment";
        return true;
      }
      return false;
    });
  }
  walkElements(
    resultTemplate.ast,
    ctx.code,
    (node, [parent]) => {
      if (node.type === "frontmatter") {
        const start = node.position.start.offset;
        if (fragmentOpened) {
          script.appendScript("</>;");
          fragmentOpened = false;
        }
        script.appendOriginal(start);
        script.skipOriginalOffset(3);
        const end = getEndOffset(node, ctx);
        const scriptStart = start + 3;
        let scriptEnd = end - 3;
        let endChar;
        while (scriptStart < scriptEnd - 1 && (endChar = script.originalCode[scriptEnd - 1]) && !endChar.trim()) {
          scriptEnd--;
        }
        script.appendOriginal(scriptEnd);
        script.appendScript("\n;");
        script.skipOriginalOffset(end - scriptEnd);
        script.addRestoreNodeProcess((_scriptNode, { result }) => {
          for (let index = 0; index < result.ast.body.length; index++) {
            const st = result.ast.body[index];
            if (st.type === import_types.AST_NODE_TYPES.EmptyStatement) {
              if (st.range[0] === scriptEnd && st.range[1] <= end) {
                result.ast.body.splice(index, 1);
                break;
              }
            }
          }
          return true;
        });
        script.addToken(import_types.AST_TOKEN_TYPES.Punctuator, [
          node.position.start.offset,
          node.position.start.offset + 3
        ]);
        script.addToken(import_types.AST_TOKEN_TYPES.Punctuator, [end - 3, end]);
      } else if (isTag(node)) {
        if (parent.type === "expression") {
          const index = parent.children.indexOf(node);
          const before = parent.children[index - 1];
          if (!before || !isTag(before)) {
            const after = parent.children[index + 1];
            if (after && (isTag(after) || after.type === "comment")) {
              const start2 = node.position.start.offset;
              script.appendOriginal(start2);
              script.appendScript("<>");
              script.addRestoreNodeProcess((scriptNode) => {
                if (scriptNode.range[0] === start2 && scriptNode.type === import_types.AST_NODE_TYPES.JSXFragment) {
                  delete scriptNode.openingFragment;
                  delete scriptNode.closingFragment;
                  const fragmentNode = scriptNode;
                  fragmentNode.type = "AstroFragment";
                  const last = fragmentNode.children[fragmentNode.children.length - 1];
                  if (fragmentNode.range[1] < last.range[1]) {
                    fragmentNode.range[1] = last.range[1];
                    fragmentNode.loc.end = ctx.getLocFromIndex(
                      fragmentNode.range[1]
                    );
                  }
                  return true;
                }
                return false;
              });
            }
          }
        }
        const start = node.position.start.offset;
        script.appendOriginal(start);
        if (!fragmentOpened) {
          openRootFragment(start);
        }
        for (const attr of node.attributes) {
          if ((node.type === "component" || node.type === "fragment") && (attr.kind === "quoted" || attr.kind === "empty" || attr.kind === "expression" || attr.kind === "template-literal")) {
            const colonIndex = attr.name.indexOf(":");
            if (colonIndex >= 0) {
              const start2 = attr.position.start.offset;
              script.appendOriginal(start2 + colonIndex);
              script.skipOriginalOffset(1);
              script.appendScript(`_`);
              script.addToken(import_types.AST_TOKEN_TYPES.JSXIdentifier, [
                start2,
                start2 + colonIndex
              ]);
              script.addToken(import_types.AST_TOKEN_TYPES.Punctuator, [
                start2 + colonIndex,
                start2 + colonIndex + 1
              ]);
              script.addToken(import_types.AST_TOKEN_TYPES.JSXIdentifier, [
                start2 + colonIndex + 1,
                start2 + attr.name.length
              ]);
              script.addRestoreNodeProcess((scriptNode, context) => {
                if (scriptNode.type === import_types.AST_NODE_TYPES.JSXAttribute && scriptNode.range[0] === start2) {
                  const baseNameNode = scriptNode.name;
                  const nsn = {
                    ...baseNameNode,
                    type: import_types.AST_NODE_TYPES.JSXNamespacedName,
                    namespace: {
                      type: import_types.AST_NODE_TYPES.JSXIdentifier,
                      name: attr.name.slice(0, colonIndex),
                      ...ctx.getLocations(
                        baseNameNode.range[0],
                        baseNameNode.range[0] + colonIndex
                      )
                    },
                    name: {
                      type: import_types.AST_NODE_TYPES.JSXIdentifier,
                      name: attr.name.slice(colonIndex + 1),
                      ...ctx.getLocations(
                        baseNameNode.range[0] + colonIndex + 1,
                        baseNameNode.range[1]
                      )
                    }
                  };
                  scriptNode.name = nsn;
                  nsn.namespace.parent = nsn;
                  nsn.name.parent = nsn;
                  context.addRemoveToken(
                    (token) => token.range[0] === baseNameNode.range[0] && token.range[1] === baseNameNode.range[1]
                  );
                  return true;
                }
                return false;
              });
            }
          }
          if (attr.kind === "shorthand") {
            const start2 = attr.position.start.offset;
            script.appendOriginal(start2);
            const jsxName = /[\s"'[\]{}]/u.test(attr.name) ? generateUniqueId(attr.name) : attr.name;
            script.appendScript(`${jsxName}=`);
            script.addRestoreNodeProcess((scriptNode) => {
              if (scriptNode.type === import_types.AST_NODE_TYPES.JSXAttribute && scriptNode.range[0] === start2) {
                const attrNode = scriptNode;
                attrNode.type = "AstroShorthandAttribute";
                const locs = ctx.getLocations(
                  ...attrNode.value.expression.range
                );
                if (jsxName !== attr.name) {
                  attrNode.name.name = attr.name;
                }
                attrNode.name.range = locs.range;
                attrNode.name.loc = locs.loc;
                return true;
              }
              return false;
            });
          } else if (attr.kind === "template-literal") {
            const attrStart = attr.position.start.offset;
            const start2 = calcAttributeValueStartOffset(attr, ctx);
            const end = calcAttributeEndOffset(attr, ctx);
            script.appendOriginal(start2);
            script.appendScript("{");
            script.appendOriginal(end);
            script.appendScript("}");
            script.addRestoreNodeProcess((scriptNode) => {
              if (scriptNode.type === import_types.AST_NODE_TYPES.JSXAttribute && scriptNode.range[0] === attrStart) {
                const attrNode = scriptNode;
                attrNode.type = "AstroTemplateLiteralAttribute";
                return true;
              }
              return false;
            });
          }
        }
        const closing = getSelfClosingTag(node, ctx);
        if (closing && closing.end === ">") {
          script.appendOriginal(closing.offset - 1);
          script.appendScript("/");
        }
        if (node.name === "script" || node.name === "style") {
          const text = node.children[0];
          if (text && text.type === "text") {
            const styleNodeStart = node.position.start.offset;
            const start2 = text.position.start.offset;
            script.appendOriginal(start2);
            script.skipOriginalOffset(text.value.length);
            script.addRestoreNodeProcess((scriptNode) => {
              if (scriptNode.type === import_types.AST_NODE_TYPES.JSXElement && scriptNode.range[0] === styleNodeStart) {
                const textNode = {
                  type: "AstroRawText",
                  value: text.value,
                  raw: text.value,
                  parent: scriptNode,
                  ...ctx.getLocations(start2, start2 + text.value.length)
                };
                scriptNode.children = [textNode];
                return true;
              }
              return false;
            });
            script.addToken(import_types.AST_TOKEN_TYPES.JSXText, [
              start2,
              start2 + text.value.length
            ]);
          }
        }
      } else if (node.type === "comment") {
        const start = node.position.start.offset;
        const end = getEndOffset(node, ctx);
        const length = end - start;
        script.appendOriginal(start);
        if (!fragmentOpened) {
          openRootFragment(start);
        }
        script.appendOriginal(start + 1);
        script.appendScript(`></`);
        script.skipOriginalOffset(length - 2);
        script.appendOriginal(end);
        script.addRestoreNodeProcess((scriptNode, context) => {
          if (scriptNode.range[0] === start && scriptNode.type === import_types.AST_NODE_TYPES.JSXFragment) {
            delete scriptNode.children;
            delete scriptNode.openingFragment;
            delete scriptNode.closingFragment;
            delete scriptNode.expression;
            const commentNode = scriptNode;
            commentNode.type = "AstroHTMLComment";
            commentNode.value = node.value;
            context.addRemoveToken(
              (token) => token.value === "<" && token.range[0] === scriptNode.range[0]
            );
            context.addRemoveToken(
              (token) => token.value === ">" && token.range[1] === scriptNode.range[1]
            );
            return true;
          }
          return false;
        });
        script.addToken("HTMLComment", [
          start,
          start + length
        ]);
      } else if (node.type === "doctype") {
        const start = node.position.start.offset;
        const end = getEndOffset(node, ctx);
        const length = end - start;
        script.appendOriginal(start);
        if (!fragmentOpened) {
          openRootFragment(start);
        }
        script.appendOriginal(start + 1);
        script.appendScript(`></`);
        script.skipOriginalOffset(length - 2);
        script.appendOriginal(end);
        script.addRestoreNodeProcess((scriptNode, context) => {
          if (scriptNode.range[0] === start && scriptNode.type === import_types.AST_NODE_TYPES.JSXFragment) {
            delete scriptNode.children;
            delete scriptNode.openingFragment;
            delete scriptNode.closingFragment;
            delete scriptNode.expression;
            const doctypeNode = scriptNode;
            doctypeNode.type = "AstroDoctype";
            context.addRemoveToken(
              (token) => token.value === "<" && token.range[0] === scriptNode.range[0]
            );
            context.addRemoveToken(
              (token) => token.value === ">" && token.range[1] === scriptNode.range[1]
            );
            return true;
          }
          return false;
        });
        script.addToken("HTMLDocType", [start, end]);
      } else {
        const start = node.position.start.offset;
        script.appendOriginal(start);
        if (!fragmentOpened) {
          openRootFragment(start);
        }
      }
    },
    (node, [parent]) => {
      if (isTag(node)) {
        const closing = getSelfClosingTag(node, ctx);
        if (!closing) {
          const end = getEndTag(node, ctx);
          if (!end) {
            const offset = calcContentEndOffset(node, ctx);
            script.appendOriginal(offset);
            script.appendScript(`</${node.name}>`);
            script.addRestoreNodeProcess((scriptNode, context) => {
              const parent2 = context.getParent(scriptNode);
              if (scriptNode.range[0] === offset && scriptNode.type === import_types.AST_NODE_TYPES.JSXClosingElement && parent2.type === import_types.AST_NODE_TYPES.JSXElement) {
                parent2.closingElement = null;
                return true;
              }
              return false;
            });
          }
        }
      }
      if ((isTag(node) || node.type === "comment") && parent.type === "expression") {
        const index = parent.children.indexOf(node);
        const after = parent.children[index + 1];
        if (!after || !isTag(after) && after.type !== "comment") {
          const before = parent.children[index - 1];
          if (before && (isTag(before) || before.type === "comment")) {
            const end = getEndOffset(node, ctx);
            script.appendOriginal(end);
            script.appendScript("</>");
          }
        }
      }
    }
  );
  if (fragmentOpened) {
    const last = resultTemplate.ast.children[resultTemplate.ast.children.length - 1];
    const end = getEndOffset(last, ctx);
    script.appendOriginal(end);
    script.appendScript("</>");
  }
  script.appendOriginal(ctx.code.length);
  return script;
  function generateUniqueId(base) {
    let candidate = `$_${base.replace(/\W/g, "_")}${uniqueIdSeq++}`;
    while (usedUniqueIds.has(candidate) || ctx.code.includes(candidate)) {
      candidate = `$_${base.replace(/\W/g, "_")}${uniqueIdSeq++}`;
    }
    usedUniqueIds.add(candidate);
    return candidate;
  }
}

// src/context/index.ts
var Context = class {
  constructor(code) {
    this.locsMap = /* @__PURE__ */ new Map();
    this.state = {};
    this.locs = new LinesAndColumns(code);
    this.code = code;
  }
  getLocFromIndex(index) {
    let loc = this.locsMap.get(index);
    if (!loc) {
      loc = this.locs.getLocFromIndex(index);
      this.locsMap.set(index, loc);
    }
    return {
      line: loc.line,
      column: loc.column
    };
  }
  getLocations(start, end) {
    return {
      range: [start, end],
      loc: {
        start: this.getLocFromIndex(start),
        end: this.getLocFromIndex(end)
      }
    };
  }
  buildToken(type, range) {
    return {
      type,
      value: this.getText(range),
      ...this.getLocations(...range)
    };
  }
  getText(range) {
    return this.code.slice(range[0], range[1]);
  }
  get originalAST() {
    return this.state.originalAST;
  }
  set originalAST(originalAST) {
    this.state.originalAST = originalAST;
  }
};
var LinesAndColumns = class {
  constructor(origCode) {
    const len = origCode.length;
    const lineStartIndices = [0];
    const crs = [];
    let normalizedCode = "";
    for (let index = 0; index < len; ) {
      const c = origCode[index++];
      if (c === "\r") {
        const next = origCode[index++] || "";
        if (next === "\n") {
          normalizedCode += next;
          crs.push(index - 2);
          lineStartIndices.push(index);
        } else {
          normalizedCode += `
${next}`;
          lineStartIndices.push(index - 1);
        }
      } else {
        normalizedCode += c;
        if (c === "\n") {
          lineStartIndices.push(index);
        }
      }
    }
    this.lineStartIndices = lineStartIndices;
    this.normalizedLineFeed = new NormalizedLineFeed(normalizedCode, crs);
  }
  getLocFromIndex(index) {
    const lineNumber = sortedLastIndex(this.lineStartIndices, index);
    return {
      line: lineNumber,
      column: index - this.lineStartIndices[lineNumber - 1]
    };
  }
  getIndexFromLoc(loc) {
    const lineStartIndex = this.lineStartIndices[loc.line - 1];
    const positionIndex = lineStartIndex + loc.column;
    return positionIndex;
  }
  getNormalizedLineFeed() {
    return this.normalizedLineFeed;
  }
};
var NormalizedLineFeed = class {
  get needRemap() {
    return this.offsets.length > 0;
  }
  constructor(code, offsets) {
    this.code = code;
    this.offsets = offsets;
    if (offsets.length) {
      const cache = {};
      this.remapIndex = (index) => {
        let result = cache[index];
        if (result != null) {
          return result;
        }
        result = index;
        for (const offset of offsets) {
          if (offset < result) {
            result++;
          } else {
            break;
          }
        }
        return cache[index] = result;
      };
    } else {
      this.remapIndex = (i) => i;
    }
  }
};
function sortedLastIndex(array, value) {
  let lower = 0;
  let upper = array.length;
  while (lower < upper) {
    const mid = Math.floor(lower + (upper - lower) / 2);
    const target = array[mid];
    if (target < value) {
      lower = mid + 1;
    } else if (target > value) {
      upper = mid;
    } else {
      return mid + 1;
    }
  }
  return upper;
}

// src/parser/astro-parser/parse.ts
var service = __toESM(require("astrojs-compiler-sync"));
function parse2(code, ctx) {
  const ast = service.parse(code, { position: true }).ast;
  if (!ast.children) {
    ast.children = [];
  }
  const htmlElement = ast.children.find(
    (n) => n.type === "element" && n.name === "html"
  );
  if (htmlElement) {
    adjustHTML(ast, htmlElement, ctx);
  }
  fixLocations(ast, ctx);
  return { ast };
}
function adjustHTML(ast, htmlElement, ctx) {
  var _a;
  const htmlEnd = ctx.code.indexOf("</html");
  if (htmlEnd == null) {
    return;
  }
  const hasTokenAfter = Boolean(ctx.code.slice(htmlEnd + 7).trim());
  const children = [...htmlElement.children];
  for (const child of children) {
    const offset = (_a = child.position) == null ? void 0 : _a.start.offset;
    if (hasTokenAfter && offset != null) {
      if (htmlEnd <= offset) {
        htmlElement.children.splice(htmlElement.children.indexOf(child), 1);
        ast.children.push(child);
      }
    }
    if (child.type === "element" && child.name === "body") {
      adjustHTMLBody(ast, htmlElement, htmlEnd, hasTokenAfter, child, ctx);
    }
  }
}
function adjustHTMLBody(ast, htmlElement, htmlEnd, hasTokenAfterHtmlEnd, bodyElement, ctx) {
  var _a;
  const bodyEnd = ctx.code.indexOf("</body");
  if (bodyEnd == null) {
    return;
  }
  const hasTokenAfter = Boolean(ctx.code.slice(bodyEnd + 7, htmlEnd).trim());
  if (!hasTokenAfter && !hasTokenAfterHtmlEnd) {
    return;
  }
  const children = [...bodyElement.children];
  for (const child of children) {
    const offset = (_a = child.position) == null ? void 0 : _a.start.offset;
    if (offset != null) {
      if (bodyEnd <= offset) {
        if (hasTokenAfterHtmlEnd && htmlEnd <= offset) {
          bodyElement.children.splice(bodyElement.children.indexOf(child), 1);
          ast.children.push(child);
        } else if (hasTokenAfter) {
          bodyElement.children.splice(bodyElement.children.indexOf(child), 1);
          htmlElement.children.push(child);
        }
      }
    }
  }
}
function fixLocations(node, ctx) {
  let start = 0;
  walk(
    node,
    ctx.code,
    (node2, [parent]) => {
      if (node2.type === "frontmatter") {
        start = node2.position.start.offset = tokenIndex(ctx, "---", start);
        if (!node2.position.end) {
          node2.position.end = {};
        }
        start = node2.position.end.offset = tokenIndex(ctx, "---", start + 3 + node2.value.length) + 3;
      } else if (node2.type === "fragment" || node2.type === "element" || node2.type === "component" || node2.type === "custom-element") {
        if (!node2.position) {
          node2.position = { start: {}, end: {} };
        }
        start = node2.position.start.offset = tokenIndex(ctx, "<", start);
        start += 1;
        start += node2.name.length;
        if (!node2.attributes.length) {
          start = calcStartTagEndOffset(node2, ctx);
        }
      } else if (node2.type === "attribute") {
        fixLocationForAttr(node2, ctx, start);
        start = calcAttributeEndOffset(node2, ctx);
        if (node2.position.end) {
          node2.position.end.offset = start;
        }
      } else if (node2.type === "comment") {
        node2.position.start.offset = tokenIndex(ctx, "<!--", start);
        start = calcCommentEndOffset(node2, ctx);
        if (node2.position.end) {
          node2.position.end.offset = start;
        }
      } else if (node2.type === "text") {
        if (parent.type === "element" && (parent.name === "script" || parent.name === "style")) {
          node2.position.start.offset = start;
          start = ctx.code.indexOf(`</${parent.name}`, start);
          if (start < 0) {
            start = ctx.code.length;
          }
        } else {
          const index = tokenIndexSafe(ctx.code, node2.value, start);
          if (index != null) {
            start = node2.position.start.offset = index;
            start += node2.value.length;
          } else {
            node2.position.start.offset = start;
            const value = node2.value.replace(/\s+/gu, "");
            for (const char of value) {
              const index2 = tokenIndex(ctx, char, start);
              start = index2 + 1;
            }
            start = skipSpaces(ctx.code, start);
            node2.value = ctx.code.slice(node2.position.start.offset, start);
          }
        }
        if (node2.position.end) {
          node2.position.end.offset = start;
        }
      } else if (node2.type === "expression") {
        start = node2.position.start.offset = tokenIndex(ctx, "{", start);
        start += 1;
      } else if (node2.type === "doctype") {
        if (!node2.position) {
          node2.position = { start: {}, end: {} };
        }
        if (!node2.position.end) {
          node2.position.end = {};
        }
        start = node2.position.start.offset = tokenIndex(ctx, "<!", start);
        start += 2;
        start = node2.position.end.offset = ctx.code.indexOf(">", start) + 1;
      } else if (node2.type === "root") {
      }
    },
    (node2, [parent]) => {
      if (node2.type === "attribute") {
        const attributes = parent.attributes;
        if (attributes[attributes.length - 1] === node2) {
          start = calcStartTagEndOffset(parent, ctx);
        }
      } else if (node2.type === "expression") {
        start = tokenIndex(ctx, "}", start) + 1;
      } else if (node2.type === "fragment" || node2.type === "element" || node2.type === "component" || node2.type === "custom-element") {
        if (!getSelfClosingTag(node2, ctx)) {
          const closeTagStart = tokenIndexSafe(
            ctx.code,
            `</${node2.name}`,
            start
          );
          if (closeTagStart != null) {
            start = closeTagStart + 2 + node2.name.length;
            start = tokenIndex(ctx, ">", start) + 1;
          }
        }
      } else {
        return;
      }
      if (node2.position.end) {
        node2.position.end.offset = start;
      }
    }
  );
}
function fixLocationForAttr(node, ctx, start) {
  if (node.kind === "empty") {
    node.position.start.offset = tokenIndex(ctx, node.name, start);
  } else if (node.kind === "quoted") {
    node.position.start.offset = tokenIndex(ctx, node.name, start);
  } else if (node.kind === "expression") {
    node.position.start.offset = tokenIndex(ctx, node.name, start);
  } else if (node.kind === "shorthand") {
    node.position.start.offset = tokenIndex(ctx, "{", start);
  } else if (node.kind === "spread") {
    node.position.start.offset = tokenIndex(ctx, "{", start);
  } else if (node.kind === "template-literal") {
    node.position.start.offset = tokenIndex(ctx, node.name, start);
  } else {
    throw new ParseError(
      `Unknown attr kind: ${node.kind}`,
      node.position.start.offset,
      ctx
    );
  }
}
function tokenIndex(ctx, token, position) {
  const index = tokenIndexSafe(ctx.code, token, position);
  if (index == null) {
    const start = token.trim() === token ? skipSpaces(ctx.code, position) : position;
    throw new ParseError(
      `Unknown token at ${start}, expected: ${JSON.stringify(
        token
      )}, actual: ${JSON.stringify(ctx.code.slice(start, start + 10))}`,
      start,
      ctx
    );
  }
  return index;
}
function tokenIndexSafe(string, token, position) {
  const index = token.trim() === token ? skipSpaces(string, position) : position;
  if (string.startsWith(token, index)) {
    return index;
  }
  return null;
}

// src/parser/lru-cache.ts
var LruCache = class extends Map {
  constructor(capacity) {
    super();
    this.capacity = capacity;
  }
  get(key) {
    if (!this.has(key)) {
      return void 0;
    }
    const value = super.get(key);
    this.set(key, value);
    return value;
  }
  set(key, value) {
    this.delete(key);
    super.set(key, value);
    if (this.size > this.capacity) {
      this.deleteOldestEntry();
    }
    return this;
  }
  deleteOldestEntry() {
    for (const entry of this) {
      this.delete(entry[0]);
      return;
    }
  }
};

// src/parser/template.ts
var lruCache = new LruCache(5);
function parseTemplate(code) {
  const cache = lruCache.get(code);
  if (cache) {
    return cache;
  }
  const ctx = new Context(code);
  const normalized = ctx.locs.getNormalizedLineFeed();
  const ctxForAstro = normalized.needRemap ? new Context(normalized.code) : ctx;
  try {
    const result = parse2((normalized == null ? void 0 : normalized.code) ?? code, ctxForAstro);
    if (normalized.needRemap) {
      remap(result, normalized, code, ctxForAstro);
      ctx.originalAST = ctxForAstro.originalAST;
    }
    const templateResult = {
      result,
      context: ctx
    };
    lruCache.set(code, templateResult);
    return templateResult;
  } catch (e) {
    if (typeof e.pos === "number") {
      const err = new ParseError(e.message, normalized == null ? void 0 : normalized.remapIndex(e.pos), ctx);
      err.astroCompilerError = e;
      throw err;
    }
    throw e;
  }
}
function remap(result, normalized, originalCode, ctxForAstro) {
  const remapDataMap = /* @__PURE__ */ new Map();
  walk(
    result.ast,
    normalized.code,
    (node) => {
      const start = normalized.remapIndex(node.position.start.offset);
      let end, value;
      if (node.position.end) {
        end = normalized.remapIndex(node.position.end.offset);
        if (node.position.start.offset === start && node.position.end.offset === end) {
          return;
        }
      }
      if (node.type === "text") {
        value = originalCode.slice(
          start,
          normalized.remapIndex(getEndOffset(node, ctxForAstro))
        );
      } else if (node.type === "comment") {
        value = originalCode.slice(
          start + 4,
          normalized.remapIndex(getEndOffset(node, ctxForAstro)) - 3
        );
      } else if (node.type === "attribute") {
        if (node.kind !== "empty" && node.kind !== "shorthand" && node.kind !== "spread") {
          let valueStart = normalized.remapIndex(
            calcAttributeValueStartOffset(node, ctxForAstro)
          );
          let valueEnd = normalized.remapIndex(
            calcAttributeEndOffset(node, ctxForAstro)
          );
          if (node.kind !== "quoted" || originalCode[valueStart] === '"' || originalCode[valueStart] === "'") {
            valueStart++;
            valueEnd--;
          }
          value = originalCode.slice(valueStart, valueEnd);
        }
      }
      remapDataMap.set(node, {
        start,
        end,
        value
      });
    },
    (_node) => {
    }
  );
  for (const [node, remapData] of remapDataMap) {
    node.position.start.offset = remapData.start;
    if (node.position.end) {
      node.position.end.offset = remapData.end;
    }
    if (node.type === "text" || node.type === "comment" || node.type === "attribute" && node.kind !== "empty" && node.kind !== "shorthand" && node.kind !== "spread") {
      node.value = remapData.value;
    }
  }
}

// src/context/parser-options.ts
var import_path3 = __toESM(require("path"));
var import_fs2 = __toESM(require("fs"));

// src/context/resolve-parser/espree.ts
var import_module2 = require("module");
var import_path2 = __toESM(require("path"));
var espreeCache = null;
function isLinterPath(p) {
  return p.includes(`eslint${import_path2.default.sep}lib${import_path2.default.sep}linter${import_path2.default.sep}linter.js`) || p.includes(`eslint${import_path2.default.sep}lib${import_path2.default.sep}linter.js`);
}
function getEspree() {
  if (!espreeCache) {
    const linterPath = Object.keys(require.cache || {}).find(isLinterPath);
    if (linterPath) {
      try {
        espreeCache = (0, import_module2.createRequire)(linterPath)("espree");
      } catch {
      }
    }
    if (!espreeCache) {
      espreeCache = require("espree");
    }
  }
  return espreeCache;
}

// src/context/resolve-parser/index.ts
function getParserForLang(attrs, parser) {
  if (parser) {
    if (typeof parser === "string" || isParserObject(parser)) {
      return parser;
    }
    if (typeof parser === "object") {
      const value = parser[attrs.lang || "js"];
      if (typeof value === "string" || isParserObject(value)) {
        return value;
      }
    }
  }
  return "espree";
}
function getParser(attrs, parser) {
  const parserValue = getParserForLang(attrs, parser);
  if (isParserObject(parserValue)) {
    return parserValue;
  }
  if (parserValue !== "espree") {
    return require(parserValue);
  }
  return getEspree();
}

// src/context/parser-options.ts
var ParserOptionsContext = class {
  constructor(options) {
    this.state = {};
    const parserOptions = {
      ecmaVersion: 2020,
      sourceType: "module",
      loc: true,
      range: true,
      raw: true,
      tokens: true,
      comment: true,
      eslintVisitorKeys: true,
      eslintScopeManager: true,
      ...options || {}
    };
    parserOptions.ecmaFeatures = {
      ...parserOptions.ecmaFeatures || {},
      jsx: true
    };
    parserOptions.sourceType = "module";
    if (parserOptions.ecmaVersion <= 5 || parserOptions.ecmaVersion == null) {
      parserOptions.ecmaVersion = 2015;
    }
    this.parserOptions = parserOptions;
  }
  getParser() {
    return getParser({}, this.parserOptions.parser);
  }
  isTypeScript() {
    var _a, _b;
    if (this.state.isTypeScript != null) {
      return this.state.isTypeScript;
    }
    const parserValue = getParserForLang({}, (_a = this.parserOptions) == null ? void 0 : _a.parser);
    if (maybeTSESLintParserObject(parserValue) || parserValue === "@typescript-eslint/parser") {
      return this.state.isTypeScript = true;
    }
    if (typeof parserValue !== "string") {
      return this.state.isTypeScript = false;
    }
    const parserName = parserValue;
    if (parserName.includes("@typescript-eslint/parser")) {
      let targetPath = parserName;
      while (targetPath) {
        const pkgPath = import_path3.default.join(targetPath, "package.json");
        if (import_fs2.default.existsSync(pkgPath)) {
          try {
            return this.state.isTypeScript = ((_b = JSON.parse(import_fs2.default.readFileSync(pkgPath, "utf-8"))) == null ? void 0 : _b.name) === "@typescript-eslint/parser";
          } catch {
            return this.state.isTypeScript = false;
          }
        }
        const parent = import_path3.default.dirname(targetPath);
        if (targetPath === parent) {
          break;
        }
        targetPath = parent;
      }
    }
    return this.state.isTypeScript = false;
  }
};

// src/parser/index.ts
function parseForESLint(code, options) {
  const { result: resultTemplate, context: ctx } = parseTemplate(code);
  const scriptContext = processTemplate(ctx, resultTemplate);
  const parserOptions = new ParserOptionsContext(options);
  const resultScript = parseScript(scriptContext.script, ctx, parserOptions);
  scriptContext.restore(resultScript);
  sort(resultScript.ast.comments);
  sort(resultScript.ast.tokens);
  extractTokens(resultScript, ctx);
  resultScript.services = Object.assign(resultScript.services || {}, {
    isAstro: true,
    getAstroAst() {
      return resultTemplate.ast;
    }
  });
  resultScript.visitorKeys = Object.assign({}, KEYS, resultScript.visitorKeys);
  return resultScript;
}
function extractTokens(ast, ctx) {
  if (!ast.ast.tokens) {
    return;
  }
  const useRanges = sort([...ast.ast.tokens, ...ast.ast.comments || []]).map(
    (t) => t.range
  );
  let range = useRanges.shift();
  for (let index = 0; index < ctx.code.length; index++) {
    while (range && range[1] <= index) {
      range = useRanges.shift();
    }
    if (range && range[0] <= index) {
      index = range[1] - 1;
      continue;
    }
    const c = ctx.code[index];
    if (!c.trim()) {
      continue;
    }
    if (isPunctuator(c)) {
      ast.ast.tokens.push(
        ctx.buildToken(import_types2.AST_TOKEN_TYPES.Punctuator, [index, index + 1])
      );
    } else {
      ast.ast.tokens.push(
        ctx.buildToken(import_types2.AST_TOKEN_TYPES.Identifier, [index, index + 1])
      );
    }
  }
  sort(ast.ast.tokens);
  function isPunctuator(c) {
    return /^[^\w$]$/iu.test(c);
  }
}

// src/astro-tools/index.ts
function parseTemplate2(code) {
  const parsed = parseTemplate(code);
  return {
    result: parsed.result,
    getEndOffset: (node) => getEndOffset(node, parsed.context),
    calcAttributeValueStartOffset: (node) => calcAttributeValueStartOffset(node, parsed.context),
    calcAttributeEndOffset: (node) => calcAttributeEndOffset(node, parsed.context),
    walk(parent, enter, leave) {
      walk(
        parent,
        code,
        enter,
        leave || (() => {
        })
      );
    },
    getLocFromIndex: (index) => parsed.context.getLocFromIndex(index),
    getIndexFromLoc: (loc) => parsed.context.locs.getIndexFromLoc(loc)
  };
}

// src/ast/index.ts
var ast_exports = {};

// src/index.ts
function parseForESLint2(code, options) {
  return parseForESLint(code, options);
}
var VisitorKeys = KEYS;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AST,
  ParseError,
  VisitorKeys,
  parseForESLint,
  parseTemplate,
  traverseNodes
});
